module.exports = [
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}),
"[project]/app/layout.tsx [app-rsc] (ecmascript, Next.js Server Component)", ((__turbopack_context__) => {

__turbopack_context__.n(__turbopack_context__.i("[project]/app/layout.tsx [app-rsc] (ecmascript)"));
}),
"[project]/app/clinical_staff.tsx [app-rsc] (client reference proxy) <module evaluation>", ((__turbopack_context__) => {
"use strict";

// This file is generated by next-core EcmascriptClientReferenceModule.
__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$server$2d$dom$2d$turbopack$2d$server$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-server-dom-turbopack-server.js [app-rsc] (ecmascript)");
;
const __TURBOPACK__default__export__ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$server$2d$dom$2d$turbopack$2d$server$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["registerClientReference"])(function() {
    throw new Error("Attempted to call the default export of [project]/app/clinical_staff.tsx <module evaluation> from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.");
}, "[project]/app/clinical_staff.tsx <module evaluation>", "default");
}),
"[project]/app/clinical_staff.tsx [app-rsc] (client reference proxy)", ((__turbopack_context__) => {
"use strict";

// This file is generated by next-core EcmascriptClientReferenceModule.
__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$server$2d$dom$2d$turbopack$2d$server$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-server-dom-turbopack-server.js [app-rsc] (ecmascript)");
;
const __TURBOPACK__default__export__ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$server$2d$dom$2d$turbopack$2d$server$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["registerClientReference"])(function() {
    throw new Error("Attempted to call the default export of [project]/app/clinical_staff.tsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.");
}, "[project]/app/clinical_staff.tsx", "default");
}),
"[project]/app/clinical_staff.tsx [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$app$2f$clinical_staff$2e$tsx__$5b$app$2d$rsc$5d$__$28$client__reference__proxy$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/app/clinical_staff.tsx [app-rsc] (client reference proxy) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$app$2f$clinical_staff$2e$tsx__$5b$app$2d$rsc$5d$__$28$client__reference__proxy$29$__ = __turbopack_context__.i("[project]/app/clinical_staff.tsx [app-rsc] (client reference proxy)");
;
__turbopack_context__.n(__TURBOPACK__imported__module__$5b$project$5d2f$app$2f$clinical_staff$2e$tsx__$5b$app$2d$rsc$5d$__$28$client__reference__proxy$29$__);
}),
"[project]/lib/dashboard-data.ts [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getAnalystDashboardData",
    ()=>getAnalystDashboardData,
    "getClinicalStaffDashboardData",
    ()=>getClinicalStaffDashboardData,
    "getDoctorDashboardData",
    ()=>getDoctorDashboardData,
    "getPatientDashboardData",
    ()=>getPatientDashboardData
]);
const API_BASE = "https://aetab8pjmb.us-east-1.awsapprunner.com/table";
async function fetchTable(table) {
    try {
        const res = await fetch(`${API_BASE}/${table}`, {
            cache: "no-store"
        });
        if (!res.ok) {
            throw new Error(`Failed to fetch ${table}`);
        }
        const body = await res.json();
        return Array.isArray(body?.data) ? body.data : [];
    } catch (error) {
        console.error(`[fetchTable] ${table}`, error);
        return [];
    }
}
const formatShortDate = (value)=>Intl.DateTimeFormat("en-US", {
        month: "short",
        day: "numeric"
    }).format(value);
const formatDateTime = (value)=>Intl.DateTimeFormat("en-US", {
        month: "short",
        day: "numeric",
        hour: "numeric",
        minute: "2-digit"
    }).format(value);
const toDate = (value)=>{
    if (!value) return null;
    const parsed = new Date(value);
    return Number.isNaN(parsed.getTime()) ? null : parsed;
};
const ensureTrend = (points, fallbackFactory)=>points.length ? points : fallbackFactory();
async function getAnalystDashboardData() {
    const [clinics, diagnoses, appointments, aiDiagnostics] = await Promise.all([
        fetchTable("clinic_servicehistory"),
        fetchTable("diagnosis"),
        fetchTable("appointments"),
        fetchTable("ai_diagnostics")
    ]);
    const hospitals = (clinics.length ? clinics : []).map((clinic)=>({
            id: clinic.clinic_id,
            name: clinic.clinic_name ?? `Clinic ${clinic.clinic_id}`,
            city: clinic.location ?? "Unknown"
        }));
    const MAX_POINTS = 180;
    const dailyCount = (records, valueKey)=>{
        const map = new Map();
        records.forEach((record)=>{
            const date = toDate(record.date);
            if (!date) return;
            const label = formatShortDate(date);
            map.set(label, (map.get(label) ?? 0) + 1);
        });
        const sorted = Array.from(map.entries()).sort((a, b)=>new Date(a[0]).getTime() - new Date(b[0]).getTime());
        const limited = sorted.slice(-MAX_POINTS);
        return limited.map(([date, value])=>({
                date,
                [valueKey]: value
            }));
    };
    const diagnosisVolume = dailyCount(diagnoses.map((d)=>({
            date: d.diagnosis_date
        })), "volume");
    const appointmentVolume = dailyCount(appointments.filter((apt)=>apt.datetime).map((apt)=>({
            date: apt.datetime
        })), "appointments");
    const aiAccuracy = (()=>{
        const map = new Map();
        aiDiagnostics.forEach((record)=>{
            if (record.confidence_score == null || !record.created_at) return;
            const label = formatShortDate(new Date(record.created_at));
            const entry = map.get(label) ?? {
                sum: 0,
                count: 0
            };
            entry.sum += record.confidence_score * 100;
            entry.count += 1;
            map.set(label, entry);
        });
        const sorted = Array.from(map.entries()).sort((a, b)=>new Date(a[0]).getTime() - new Date(b[0]).getTime());
        const limited = sorted.slice(-MAX_POINTS);
        return limited.map(([date, { sum, count }])=>({
                date,
                accuracy: count ? Number((sum / count).toFixed(1)) : 0
            }));
    })();
    const retention = (()=>{
        const map = new Map();
        appointments.forEach((apt)=>{
            if (!apt.datetime) return;
            const label = formatShortDate(new Date(apt.datetime));
            const entry = map.get(label) ?? {
                total: 0,
                completed: 0
            };
            entry.total += 1;
            if (apt.status?.toLowerCase() === "completed") {
                entry.completed += 1;
            }
            map.set(label, entry);
        });
        const sorted = Array.from(map.entries()).sort((a, b)=>new Date(a[0]).getTime() - new Date(b[0]).getTime());
        const limited = sorted.slice(-MAX_POINTS);
        return limited.map(([date, { total, completed }])=>{
            const percent = total ? Number((completed / total * 100).toFixed(1)) : 0;
            return {
                date,
                retention: percent
            };
        });
    })();
    const fallbackTrend = (key)=>[
            "Mon",
            "Tue",
            "Wed",
            "Thu",
            "Fri",
            "Sat",
            "Sun"
        ].map((day)=>({
                date: day,
                [key]: 1
            }));
    const accuracyFallback = ()=>fallbackTrend("accuracy").map((point)=>({
                ...point,
                accuracy: 90 + point.accuracy
            }));
    const retentionFallback = ()=>fallbackTrend("retention").map((point)=>({
                ...point,
                retention: 85 + point.retention
            }));
    const kpiMetrics = {
        diagnosisVolume: ensureTrend(diagnosisVolume, ()=>fallbackTrend("volume")),
        appointmentVolume: ensureTrend(appointmentVolume, ()=>fallbackTrend("appointments")),
        aiAccuracy: ensureTrend(aiAccuracy, accuracyFallback),
        retention: ensureTrend(retention, retentionFallback)
    };
    const summary = {
        aiAccuracy: kpiMetrics.aiAccuracy.at(-1)?.accuracy ?? 0,
        retention: kpiMetrics.retention.at(-1)?.retention ?? 0,
        diagnosesTotal: kpiMetrics.diagnosisVolume.reduce((sum, point)=>sum + point.volume, 0),
        appointmentsTotal: kpiMetrics.appointmentVolume.reduce((sum, point)=>sum + point.appointments, 0)
    };
    return {
        hospitals: hospitals.length ? hospitals : [
            {
                id: 0,
                name: "Network Wide",
                city: "Canada"
            }
        ],
        kpiMetrics,
        summary
    };
}
const statusLabel = (value)=>{
    const normalized = value.toLowerCase();
    if (normalized.includes("resolve")) return "Stable";
    if (normalized.includes("chronic")) return "Recovery";
    return "Monitoring";
};
const metricStatus = (label, value)=>{
    if (label === "Heart Rate") {
        return value >= 60 && value <= 100 ? "Normal" : "Review";
    }
    if (label === "Temperature") {
        return value >= 36 && value <= 37.5 ? "Normal" : "Review";
    }
    return "Normal";
};
async function getClinicalStaffDashboardData() {
    const [clinics, staff, doctors, appointments, patients, history, vitals, helpTickets] = await Promise.all([
        fetchTable("clinic_servicehistory"),
        fetchTable("clinical_staff_registration"),
        fetchTable("doctors_registration"),
        fetchTable("appointments"),
        fetchTable("patients_registration"),
        fetchTable("medical_history"),
        fetchTable("vitals_history"),
        fetchTable("clinic_help")
    ]);
    const staffCounts = staff.reduce((acc, entry)=>{
        if (!entry.clinic_id) return acc;
        acc[entry.clinic_id] = (acc[entry.clinic_id] ?? 0) + 1;
        return acc;
    }, {});
    const activeClinics = clinics.filter((clinic)=>clinic.active);
    const departments = (activeClinics.length ? activeClinics : clinics).slice(0, 3).map((clinic)=>({
            id: clinic.clinic_id,
            name: clinic.clinic_name ?? `Clinic ${clinic.clinic_id}`,
            hospital: clinic.location ?? "Regional",
            staffCount: staffCounts[clinic.clinic_id] ?? 0
        }));
    const doctorClinicMap = doctors.reduce((acc, doctor)=>{
        if (doctor.doctor_id && doctor.clinic_id) {
            acc[doctor.doctor_id] = doctor.clinic_id;
        }
        return acc;
    }, {});
    const patientMap = patients.reduce((acc, patient)=>{
        acc[patient.patient_id] = patient;
        return acc;
    }, {});
    const historyMap = history.reduce((acc, entry)=>{
        acc[entry.patient_id] = entry;
        return acc;
    }, {});
    const patientsByDepartment = {};
    const appointmentsByDepartment = {};
    const followUpsByDepartment = {};
    const alertsByDepartment = {};
    const metricsByPatient = {};
    const vitalsByPatient = vitals.reduce((acc, entry)=>{
        if (!entry.patient_id) return acc;
        acc[entry.patient_id] = acc[entry.patient_id] ?? [];
        acc[entry.patient_id].push(entry);
        return acc;
    }, {});
    departments.forEach((dept)=>{
        patientsByDepartment[dept.id] = [];
        appointmentsByDepartment[dept.id] = [];
        followUpsByDepartment[dept.id] = [];
        alertsByDepartment[dept.id] = [];
    });
    const deptRoom = (clinicId)=>{
        const clinic = clinics.find((c)=>c.clinic_id === clinicId);
        return clinic ? `${clinic.clinic_name} Wing` : "Care Suite";
    };
    appointments.forEach((appointment)=>{
        const clinicId = doctorClinicMap[appointment.doctor_id];
        if (!clinicId || !patientsByDepartment[clinicId]) return;
        const details = patientMap[appointment.patient_id];
        if (!details) return;
        const patientList = patientsByDepartment[clinicId];
        if (!patientList.find((p)=>p.id === appointment.patient_id)) {
            const medical = historyMap[appointment.patient_id];
            patientList.push({
                id: appointment.patient_id,
                name: details.name,
                admitted: formatShortDate(toDate(appointment.datetime) ?? new Date()),
                condition: medical?.condition ?? "General Care",
                status: medical ? statusLabel(medical.status) : "Monitoring"
            });
        }
        const isFuture = (()=>{
            const date = toDate(appointment.datetime);
            return date ? date.getTime() >= Date.now() : false;
        })();
        if (isFuture && appointmentsByDepartment[clinicId].length < 3) {
            appointmentsByDepartment[clinicId].push({
                patientName: details.name,
                type: appointment.status,
                date: formatDateTime(toDate(appointment.datetime) ?? new Date()),
                room: deptRoom(clinicId)
            });
        }
    });
    departments.forEach((dept)=>{
        const followUps = history.filter((record)=>record.followup_required && patientsByDepartment[dept.id].some((patient)=>patient.id === record.patient_id));
        followUpsByDepartment[dept.id] = followUps.slice(0, 3).map((record)=>({
                patientName: patientMap[record.patient_id]?.name ?? `Patient ${record.patient_id}`,
                followUp: record.diagnosis_date ? formatShortDate(new Date(record.diagnosis_date)) : "Pending",
                reason: `${record.condition} • ${record.severity ?? "Review"}`
            }));
        const deptTickets = helpTickets.filter((ticket)=>ticket.clinic_id === dept.id).slice(0, 3);
        alertsByDepartment[dept.id] = (deptTickets.length ? deptTickets : helpTickets.slice(0, 3)).map((ticket, index)=>({
                patientName: ticket.submitted_by,
                alert: ticket.issue_description,
                severity: ticket.issue_description.toLowerCase().includes("emergency") ? "critical" : index === 0 ? "warning" : "info",
                time: `${15 * (index + 1)} min ago`
            }));
    });
    Object.entries(vitalsByPatient).forEach(([patientId, records])=>{
        const latest = records.sort((a, b)=>(toDate(b.recorded_on)?.getTime() ?? 0) - (toDate(a.recorded_on)?.getTime() ?? 0))[0];
        if (!latest) return;
        const metrics = [];
        if (latest.blood_pressure) {
            metrics.push({
                metric: "Blood Pressure",
                value: latest.blood_pressure,
                status: "Normal"
            });
        }
        if (typeof latest.heart_rate === "number") {
            metrics.push({
                metric: "Heart Rate",
                value: `${latest.heart_rate} bpm`,
                status: metricStatus("Heart Rate", latest.heart_rate)
            });
        }
        if (typeof latest.temperature === "number") {
            metrics.push({
                metric: "Temperature",
                value: `${latest.temperature.toFixed(1)}°C`,
                status: metricStatus("Temperature", latest.temperature)
            });
        }
        if (typeof latest.respiratory_rate === "number") {
            metrics.push({
                metric: "Respiratory Rate",
                value: `${latest.respiratory_rate} rpm`,
                status: "Normal"
            });
        }
        metricsByPatient[Number(patientId)] = metrics.length ? metrics : [
            {
                metric: "No vitals available",
                value: "Awaiting data",
                status: "Review"
            }
        ];
    });
    return {
        departments,
        patientsByDepartment,
        appointmentsByDepartment,
        followUpsByDepartment,
        alertsByDepartment,
        metricsByPatient
    };
}
const parseBloodPressure = (value)=>{
    if (!value) return null;
    const [systolic, diastolic] = value.split("/").map((part)=>Number(part));
    if (Number.isNaN(systolic) || Number.isNaN(diastolic)) return null;
    return {
        systolic,
        diastolic
    };
};
const calculateAge = (dob)=>{
    if (!dob) return 0;
    const birth = new Date(dob);
    if (Number.isNaN(birth.getTime())) return 0;
    const diff = Date.now() - birth.getTime();
    return Math.max(0, Math.floor(diff / (365.25 * 24 * 60 * 60 * 1000)));
};
async function getDoctorDashboardData(doctorId = 1) {
    const [doctors, appointments, patients, vitals, prescriptions, tasks] = await Promise.all([
        fetchTable("doctors_registration"),
        fetchTable("appointments"),
        fetchTable("patients_registration"),
        fetchTable("vitals_history"),
        fetchTable("prescription"),
        fetchTable("doctor_tasks")
    ]);
    const doctor = doctors.find((entry)=>entry.doctor_id === doctorId);
    const doctorAppointments = appointments.filter((apt)=>apt.doctor_id === doctorId);
    const patientMap = patients.reduce((acc, patient)=>{
        acc[patient.patient_id] = patient;
        return acc;
    }, {});
    const patientsCards = [];
    const patientIds = new Set();
    doctorAppointments.forEach((apt)=>{
        if (patientIds.has(apt.patient_id)) return;
        patientIds.add(apt.patient_id);
        const patient = patientMap[apt.patient_id];
        if (!patient) return;
        const lastVisitDate = doctorAppointments.filter((entry)=>entry.patient_id === apt.patient_id).map((entry)=>toDate(entry.datetime)?.getTime() ?? 0).sort((a, b)=>b - a)[0] ?? Date.now();
        patientsCards.push({
            id: patient.patient_id,
            name: patient.name,
            age: calculateAge(patient.dob),
            lastVisit: formatShortDate(new Date(lastVisitDate))
        });
    });
    const vitalsByPatient = doctorAppointments.reduce((acc, apt)=>{
        const patientVitals = vitals.filter((record)=>record.patient_id === apt.patient_id && record.blood_pressure).sort((a, b)=>(toDate(a.recorded_on)?.getTime() ?? 0) - (toDate(b.recorded_on)?.getTime() ?? 0)).slice(-7).map((record)=>{
            const bp = parseBloodPressure(record.blood_pressure);
            return {
                date: formatShortDate(toDate(record.recorded_on) ?? new Date()),
                systolic: bp?.systolic ?? 0,
                diastolic: bp?.diastolic ?? 0,
                heartRate: record.heart_rate ?? 0
            };
        });
        if (patientVitals.length) {
            acc[apt.patient_id] = patientVitals;
        }
        return acc;
    }, {});
    const currentPrescriptions = prescriptions.filter((rx)=>rx.doctor_id === doctorId && rx.status?.toLowerCase() === "active").map((rx)=>({
            drug: rx.medicine_name,
            dose: rx.dosage ?? "As directed",
            frequency: rx.dosage ?? "Per instructions",
            since: rx.start_date ? formatShortDate(new Date(rx.start_date)) : "Ongoing"
        }));
    const previousPrescriptions = prescriptions.filter((rx)=>rx.doctor_id === doctorId && rx.status?.toLowerCase() !== "active").map((rx)=>({
            drug: rx.medicine_name,
            dose: rx.dosage ?? "As directed",
            frequency: rx.dosage ?? "Per instructions",
            since: rx.end_date ? formatShortDate(new Date(rx.end_date)) : "Completed"
        }));
    const upcomingAppointments = doctorAppointments.filter((apt)=>{
        const date = toDate(apt.datetime);
        return date ? date.getTime() >= Date.now() && apt.status?.toLowerCase() === "scheduled" : false;
    }).slice(0, 3).map((apt)=>({
            patientName: patientMap[apt.patient_id]?.name ?? `Patient ${apt.patient_id}`,
            date: formatDateTime(toDate(apt.datetime) ?? new Date()),
            type: apt.status
        }));
    const doctorAlerts = tasks.filter((task)=>task.doctor_id === doctorId).slice(0, 2).map((task)=>({
            message: task.description,
            tone: task.status.toLowerCase() === "in progress" ? "warning" : "info"
        }));
    return {
        doctorName: doctor?.name ?? `Doctor ${doctorId}`,
        patients: patientsCards.slice(0, 3),
        vitalsByPatient,
        currentPrescriptions,
        previousPrescriptions,
        upcomingAppointments,
        alerts: doctorAlerts.length ? doctorAlerts : [
            {
                message: "No outstanding physician tasks",
                tone: "info"
            },
            {
                message: "All lab reviews completed",
                tone: "warning"
            }
        ]
    };
}
async function getPatientDashboardData(patientId = 1) {
    const [patients, appointments, doctors, clinics, vitals, bloodTests, prescriptions, labTests, messageHubs] = await Promise.all([
        fetchTable("patients_registration"),
        fetchTable("appointments"),
        fetchTable("doctors_registration"),
        fetchTable("clinic_servicehistory"),
        fetchTable("vitals_history"),
        fetchTable("bloodtests"),
        fetchTable("prescription"),
        fetchTable("lab_tests"),
        fetchTable("patient_message_hub")
    ]);
    const patient = patients.find((entry)=>entry.patient_id === patientId);
    const doctorMap = doctors.reduce((acc, doc)=>{
        acc[doc.doctor_id] = doc;
        return acc;
    }, {});
    const clinicMap = clinics.reduce((acc, clinic)=>{
        acc[clinic.clinic_id] = clinic;
        return acc;
    }, {});
    const patientAppointments = appointments.filter((apt)=>apt.patient_id === patientId && apt.datetime).slice(0, 3).map((apt)=>{
        const doctor = doctorMap[apt.doctor_id];
        const location = clinicMap[doctor?.clinic_id ?? 0]?.clinic_name ?? "Virtual Visit";
        return {
            doctor: doctor?.name ?? `Doctor ${apt.doctor_id}`,
            date: formatDateTime(toDate(apt.datetime) ?? new Date()),
            location
        };
    });
    const patientVitals = vitals.filter((record)=>record.patient_id === patientId).sort((a, b)=>(toDate(a.recorded_on)?.getTime() ?? 0) - (toDate(b.recorded_on)?.getTime() ?? 0)).slice(-7);
    const patientGlucose = bloodTests.filter((record)=>record.patient_id === patientId && record.test_name.toLowerCase().includes("glucose")).sort((a, b)=>new Date(a.test_date).getTime() - new Date(b.test_date).getTime()).slice(-7);
    const healthMetrics = patientVitals.length > 0 ? patientVitals.map((record, index)=>{
        const bp = parseBloodPressure(record.blood_pressure);
        const glucose = patientGlucose[index]?.result_value;
        return {
            date: formatShortDate(toDate(record.recorded_on) ?? new Date()),
            bloodPressure: bp?.systolic ?? 0,
            heartRate: record.heart_rate ?? 0,
            glucose: glucose ? Number(glucose) : 0
        };
    }) : [
        // Minimal mock data when vitals are unavailable to keep the chart visible.
        {
            date: "Mon",
            bloodPressure: 120,
            heartRate: 72,
            glucose: 95
        },
        {
            date: "Tue",
            bloodPressure: 118,
            heartRate: 70,
            glucose: 96
        },
        {
            date: "Wed",
            bloodPressure: 122,
            heartRate: 74,
            glucose: 98
        },
        {
            date: "Thu",
            bloodPressure: 119,
            heartRate: 71,
            glucose: 97
        },
        {
            date: "Fri",
            bloodPressure: 121,
            heartRate: 73,
            glucose: 99
        },
        {
            date: "Sat",
            bloodPressure: 117,
            heartRate: 69,
            glucose: 94
        },
        {
            date: "Sun",
            bloodPressure: 120,
            heartRate: 72,
            glucose: 95
        }
    ];
    const medications = prescriptions.filter((rx)=>rx.patient_id === patientId && rx.status?.toLowerCase() === "active").map((rx)=>({
            name: rx.medicine_name,
            dosage: rx.dosage ?? "Per instructions"
        }));
    const medicalRecords = labTests.filter((record)=>record.patient_id === patientId).slice(0, 3).map((record)=>({
            type: record.test_type,
            description: `${record.test_type} • ${record.result}`,
            date: formatShortDate(new Date(record.test_date)),
            status: record.status,
            statusTone: record.status.toLowerCase() === "completed" ? "success" : "warning"
        }));
    const tasks = messageHubs.filter((hub)=>hub.patient_id === patientId).slice(0, 2).map((hub)=>({
            title: hub.summary,
            createdDate: formatDateTime(new Date(hub.last_updated))
        }));
    return {
        patientName: patient?.name ?? `Patient ${patientId}`,
        appointments: patientAppointments,
        healthMetrics,
        medications: medications.length ? medications : [
            {
                name: "Medication list empty",
                dosage: "Awaiting prescriptions"
            }
        ],
        medicalRecords,
        tasks: tasks.length ? tasks : [
            {
                title: "No pending tasks",
                createdDate: formatDateTime(new Date())
            }
        ]
    };
}
}),
"[project]/app/(routes)/clinical_staff/page.tsx [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>ClinicalStaffRoute,
    "dynamic",
    ()=>dynamic
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$dev$2d$runtime$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-jsx-dev-runtime.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$app$2f$clinical_staff$2e$tsx__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/app/clinical_staff.tsx [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$dashboard$2d$data$2e$ts__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/lib/dashboard-data.ts [app-rsc] (ecmascript)");
;
;
;
const dynamic = "force-dynamic";
async function ClinicalStaffRoute() {
    const data = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$dashboard$2d$data$2e$ts__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getClinicalStaffDashboardData"])();
    return /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$rsc$2f$react$2d$jsx$2d$dev$2d$runtime$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["jsxDEV"])(__TURBOPACK__imported__module__$5b$project$5d2f$app$2f$clinical_staff$2e$tsx__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"], {
        ...data
    }, void 0, false, {
        fileName: "[project]/app/(routes)/clinical_staff/page.tsx",
        lineNumber: 8,
        columnNumber: 10
    }, this);
}
}),
"[project]/app/(routes)/clinical_staff/page.tsx [app-rsc] (ecmascript, Next.js Server Component)", ((__turbopack_context__) => {

__turbopack_context__.n(__turbopack_context__.i("[project]/app/(routes)/clinical_staff/page.tsx [app-rsc] (ecmascript)"));
}),
];

//# sourceMappingURL=%5Broot-of-the-server%5D__2903d040._.js.map